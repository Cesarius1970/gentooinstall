#!/usr/bin/env bash

NAME="Gentoo Install"
CODENAME="gentooinstall"
COPYRIGHT="Copyright (C) 2016 Nathan Shearer & Cesar Vergara"
LICENSE="GNU General Public License 2.0"
VERSION="2.0.0.2020"

# \brief Displays the help and exits the program
function gentooinstall_help
{
	#     01234567890123456789012345678901234567890123456789012345678901234567890123456789
	echo "Description:"
	echo "  Install Gentoo Linux by automating most of the steps in the Gentoo Handbook."
	echo
	echo "Usage:"
	echo "  $CODENAME [options]"
	echo
	echo "Options:"
	#echo "  --assimilate"
	#echo "    Convert the destination into Gentoo Linux."
	echo "  -a, --architecture x86_64"
	echo "    Which guest architecture to install. Default is the host architecture."
	echo "    Supported architectures are:"
	echo "      i486, i686, x86_64,"
	echo "      armv4, armv5, armv6, armv6hf, armv7, armv7hf, aarch64,"
	echo "      ppc, ppc64,"
	echo "      alpha"
	echo "  --bootloader uefi-refind"
	echo "    Which bootloader to install on the boot device:"
	echo "      bios-lilo"
	echo "      uefi-refind"
	echo "      grub-efi  default"
	echo "  -d, --destination /mnt/gentoo"
	echo "    Install into this location. If a directory is provided, then install into"
	echo "    that directory. If an empty block device is provided, then it will be"
	echo "    partitioned and mounted. Default mountpoint is \"/mnt/gentoo\"."
	echo "  --destination-root-partuuid 00000000-0000-0000-0000-000000000000"
	echo "    Specify the destination root partuuid instead of automatically detecting it."
	echo "  -h, --help"
	echo "    Display this help message and exit."
	echo "  --no-news"
	echo "    Do not display unread news items."
	echo "  --no-warning"
	echo "    Do not display or wait for the 10-second pre-install warning."
	echo "  -m, --mountpoint /mnt/gentoo"
	echo "    Where to mount the destination block devices. Default is \"/mnt/gentoo\""
	echo "  --mirror http://distfiles.gentoo.org"
	echo "    Download the stage3 files from a different mirror."
	echo "  --password password"
	echo "    Set the root password to \"password\"."
	echo "  --partition-type gpt"
	echo "    The type of a partition table to create: gpt or msdos."
	echo "  --partition-block-size $((1024*1024))"
	echo "    The block size used for partition alignment."
	echo "  -p, --phase phase1,phase2,..."
	echo "    A comma-separated list of which phases to run:"
	echo "      partition           conditional  Partition an empty block device"
	echo "      mount               conditional  Mount the destination block device"
	echo "      stage3download      default      Download the stage 3 tarball"
	echo "      stage3signature     default      Verify the cryptographic signature"
	echo "      stage3hash          default      Verify the hash"
	echo "      stage3extract       default      Extract the stage 3 tarball"
	echo "      stage3delete        default      Delete the stage 3 tarball"
	echo "      dynamictranslation  default      Enable dynamic translation if required"
	echo "      resolvconf          default      Add default nameservers"
	echo "      procsysdev          automatic    Mount proc, sys, and dev"
	echo "      portage             default      Install Portage"
	echo "      timezone            default      Set the timezone"
	echo "      locale              default      Set the locale"
	echo "      kernel                           Install and compile the kernel"
	echo "      fstab                            Add boot, root, and swap entries"
	echo "      bootloader                       Configure and install a bootloader"
	echo "      update              default      Update the world"
	echo "      password            default      Set the root password"
	echo "  --portage latest"
	echo "    Install the latest portage snapshot or provide a URL to a different version."
	echo "  --stage3 latest"
	echo "    Install the latest stage3 tarball or provide a URL to a different version."
	echo "  -t, --timezone \"UTC\""
	echo "    Which timezone to configure."
	echo
	echo "Examples:"
	echo "  $CODENAME -d /dev/sdzz -t \"Canada/Mountain\""
	echo "  $CODENAME -p kernel,fstab,bootloader"
	echo
	echo "Version:"
	echo "  $NAME $VERSION"
	echo "  $COPYRIGHT"
	echo "  Licensed under $LICENSE"
	exit
}

function gentooinstall_architecture
{
	if uname -m | grep -qx "alpha"; then
		echo "alpha"
	elif uname -m | grep -q "armv4"; then
		echo "armv4"
	elif uname -m | grep -q "armv5"; then
		echo "armv5"
	elif uname -m | grep -q "armv6"; then
		if grep -q vfp /proc/cpuinfo; then
			echo "armv6hf"
		else
			echo "armv6"
		fi
	elif uname -m | grep -q "armv7"; then
		if grep -q vfp /proc/cpuinfo; then
			echo "armv7hf"
		else
			echo "armv7"
		fi
	elif uname -m | grep -q "aarch64"; then
		echo "aarch64"
	elif uname -m | grep -qx "i386"; then
		echo "i386"
	elif uname -m | grep -qx "i686"; then
		echo "i686"
	elif uname -m | grep -qx "mips"; then
		echo "mips"
	elif uname -m | grep -qx "ppc"; then
		echo "ppc"
	elif uname -m | grep -qx "ppc64"; then
		echo "ppc64"
	elif uname -m | grep -qx "sparc64"; then
		echo "sparc64"
	elif uname -m | grep -qx "x86_64"; then
		echo "x86_64"
	elif uname -m | grep -qx "amd64"; then
		echo "x86_64"
	else
		echo "unknown"
	fi
}

# \brief Convert an image to a new Gentoo installation
function gentooinstall_assimilate
{
	#give the user a chance to cancel the install
	if $WARNING; then
		echo "Installing Gentoo at \"$DESTINATION_ROOT\"..."
		echo
		echo "We are the Gentoo Community."
		sleep 2
		echo "Power your systems and surrender your chips."
		sleep 2
		echo "Your ideological and technological distinctiveness will be added to our own."
		sleep 2
		echo "You will adapt to serve us."
		sleep 2
		echo "Resistance is futile."
		sleep 2
		echo
	fi
	
	echo "not complete"
	exit 1
}

# \brief Ensures dependencies are present
# \param $@ The dependencies to check for
function gentooinstall_check_dependencies
{
	for TOOL in "$@"; do
		if ! type "$TOOL" >/dev/null 2>/dev/null; then
			echo "$CODENAME: \"$TOOL\" is required for this application to work correctly." >&2
			exit 1
		fi
	done
}

function show_phase
{
	echo -n "<<<<<< ${CURRENT_PHASE} >>>>>>"
	read -p "Press any key..."
}

function gentooinstall_detect_boot_device
{
	gentooinstall_check_dependencies findmnt lsblk
	
	if [ "$DESTINATION_BOOT_DEVICE" = "" ]; then
		DESTINATION_BOOT_DEVICE=$(findmnt -n -o SOURCE "$DESTINATION_ROOT/boot")
		if [ ! -b "$DESTINATION_BOOT_DEVICE" ]; then
			for PARTITION in $(lsblk -f -n -o PATH "$DESTINATION" | tail -n +2); do
				local FSTYPE=$(lsblk -f -n -o FSTYPE "$PARTITION")
				if [ "$FSTYPE" = "vfat" ]; then
					DESTINATION_BOOT_DEVICE="$PARTITION"
				fi
			done
		fi
		if [ ! -b "$DESTINATION_BOOT_DEVICE" ]; then
			echo "error: detect_boot_device: Unable to detect the boot device."
			return 1
		fi
		echo "Detected Boot Device: \"$DESTINATION_BOOT_DEVICE\""
	fi
}

function gentooinstall_detect_boot_device_parent
{
	gentooinstall_check_dependencies findmnt lsblk
	
	if [ "$DESTINATION_BOOT_DEVICE_PARENT" = "" ]; then
		local DEVICE_BOOT=$(findmnt -n -o SOURCE "$DESTINATION_ROOT/boot")
		DESTINATION_BOOT_DEVICE_PARENT="/dev/$(lsblk -s -l -n -o NAME "$DEVICE_BOOT" | tail -n 1)"
		if [ ! -b "$DESTINATION_BOOT_DEVICE_PARENT" ]; then
			echo "error: detect_boot_device: Unable to detect the boot device. \"$DESTINATION_BOOT_DEVICE\" is not a block device."
			return 1
		fi
	fi
}

function gentooinstall_detect_boot_uuid
{
	gentooinstall_check_dependencies findmnt lsblk
	
	if [ "$DESTINATION_BOOT_UUID" = "" ]; then
		local DEVICE_BOOT=$(findmnt -n -o SOURCE "$DESTINATION_ROOT/boot/efi")
		DESTINATION_BOOT_UUID=$(lsblk -f -n -o UUID "$DEVICE_BOOT")
		findfs "UUID=$DESTINATION_BOOT_UUID" >/dev/null 2>/dev/null
		if [ $? -ne 0 ]; then
			echo "error: detect_boot_uuid: Unable to detect the UUID of the filesystem mounted at \"$DESTINATION_ROOT/boot/efi\""
			return 1
		fi
	fi
}

function gentooinstall_detect_root_device
{
	if [ "$DESTINATION_ROOT_DEVICE" = "" -a -b "$DESTINATION" ]; then
		for PARTITION in $(lsblk -f -n -o PATH "$DESTINATION" | tail -n +2); do
			local FSTYPE=$(lsblk -f -n -o FSTYPE "$PARTITION")
			if [ "$FSTYPE" = "swap" ]; then continue; fi
			if [ "$FSTYPE" = "vfat" ]; then continue; fi
			DESTINATION_ROOT_DEVICE="$PARTITION"
		done
		if [ ! -b "$DESTINATION_ROOT_DEVICE" ]; then
			echo "error: detect_root_device: Unable to detect the root device. \"$DESTINATION_ROOT_DEVICE\" is not a block device."
			return 1
		fi
		echo "Detected Root Device: \"$DESTINATION_ROOT_DEVICE\""
	fi
}

function gentooinstall_detect_root_partuuid
{
	gentooinstall_check_dependencies findmnt lsblk
	
	if [ "$DESTINATION_ROOT_PARTUUID" = "" ]; then
		local DEVICE_ROOT=$(findmnt -n -o SOURCE "$DESTINATION_ROOT")
		DESTINATION_ROOT_PARTUUID=$(lsblk -f -n -o PARTUUID "$DEVICE_ROOT")
		findfs "PARTUUID=$DESTINATION_ROOT_PARTUUID" >/dev/null 2>/dev/null
		if [ $? -ne 0 ]; then
			echo "error: detect_root_partuuid: Unable to detect the PARTUUID of the filesystem mounted at \"$DESTINATION_ROOT\""
			return 1
		fi
		echo "Detected Root PARTUUID: \"$DESTINATION_ROOT_PARTUUID\""
	fi
}

function gentooinstall_detect_root_uuid
{
	gentooinstall_check_dependencies findmnt lsblk
	
	if [ "$DESTINATION_ROOT_UUID" = "" ]; then
		local DEVICE_ROOT=$(findmnt -n -o SOURCE "$DESTINATION_ROOT")
		DESTINATION_ROOT_UUID=$(lsblk -f -n -o UUID "$DEVICE_ROOT")
		findfs "UUID=$DESTINATION_ROOT_UUID" >/dev/null 2>/dev/null
		if [ $? -ne 0 ]; then
			echo "error: detect_root_uuid: Unable to detect the UUID of the filesystem mounted at \"$DESTINATION_ROOT\""
			return 1
		fi
	fi
}

function gentooinstall_detect_swap_uuid
{
	gentooinstall_check_dependencies findfs findmnt lsblk parted
	
	if [ "$DESTINATION_SWAP_UUID" = "" ]; then
		local DEVICE_ROOT=$(findmnt -n -o SOURCE "$DESTINATION_ROOT")
		local DEVICE_ROOT_PARENT=$(lsblk -s -l -n -o NAME "$DEVICE_ROOT" | tail -n 1)
		local SWAP_INDEX=$(parted -s -m "/dev/$DEVICE_ROOT_PARENT" p | grep linux-swap | cut -d : -f 1)
		DESTINATION_SWAP_UUID=$(lsblk -f -n -o UUID "/dev/$DEVICE_ROOT_PARENT"*$SWAP_INDEX)
		findfs "UUID=$DESTINATION_SWAP_UUID" >/dev/null 2>/dev/null
		if [ $? -ne 0 ]; then
			echo "error: detect_swap_uuid: Unable to detect the UUID of the swap partition"
			return 1
		fi
	fi
}

##################################################################
# \brief Iterate through each phase
function gentooinstall_phases
{
	local CURRENT_PHASE=$(echo -n "$PHASES" | sed -r -e 's/([^,]+),?.*?/\1/')
	local REMAINING_PHASES=$(echo -n "$PHASES" | sed -r -e 's/[^,]+,?(.*?)/\1/')
	show_phase
	while [ "$CURRENT_PHASE" != "" ]; do
		case "$CURRENT_PHASE" in
			"partition")          gentooinstall_phase_partition;;
			"mount")              gentooinstall_phase_mount;;
			"stage3download-no")  gentooinstall_phase_stage3download-no;;
			"stage3download")     gentooinstall_phase_stage3download;;
			"stage3extract")      gentooinstall_phase_stage3extract;;
			"stage3delete")       gentooinstall_phase_stage3delete;;
			"resolvconf")         gentooinstall_phase_resolvconf;;
			"dynamictranslation") gentooinstall_phase_dynamictranslation;;
			"procsysdev")         gentooinstall_phase_procsysdev;;
			"portage")            gentooinstall_phase_portage;;
			"timezone")           gentooinstall_phase_timezone;;
			"locale")             gentooinstall_phase_locale;;
			"kernel")             gentooinstall_phase_kernel;;
			"fstab")              gentooinstall_phase_fstab;;
			"network")            gentooinstall_phase_network;;
			"bootloader")         gentooinstall_phase_bootloader;;
			"update")             gentooinstall_phase_update;;
			"password")           gentooinstall_phase_password;;
			*)
				echo "error: unknown phase: \"$CURRENT_PHASE\""
				return 1
				;;
		esac
		if [ $? -ne 0 ]; then
			echo "error: the $CURRENT_PHASE phase encountered an error"
			return 2
		fi
		CURRENT_PHASE=$(echo -n "$REMAINING_PHASES" | sed -r -e 's/([^,]+),?.*?/\1/')
		REMAINING_PHASES=$(echo -n "$REMAINING_PHASES" | sed -r -e 's/[^,]+,?(.*?)/\1/')
	done
}

# \brief Display unread news items
function gentooinstall_news
{
	$NEWS || return 0

	if [ -e "$DESTINATION_ROOT/usr/bin/eselect" ]; then
		gentooinstall_phase_procsysdev
		local PREFIX="$CHROOTARCH chroot $DESTINATION_ROOT"
		if [ "$DESTINATION" = "/" ]; then
			PREFIX=""
		fi

		NEWS_COUNT=$($PREFIX eselect news count)
		if [ "$NEWS_COUNT" != "0" ]; then
			$PREFIX eselect news list
		fi
	fi
}

function gentooinstall_phase_partition
{
	if [ ! -b "$DESTINATION" ]; then
		echo "error: \"$DESTINATION\" is not a block device"
		return 1
	fi
	if mount | grep "$DESTINATION"; then
		echo "error: \"$DESTINATION\" is currently mounted"
		return 2
	fi
	if ! diff -q <(dd bs=512 count=1 if="$DESTINATION" >/dev/null 2>/dev/null) <(dd bs=512 count=1 if=/dev/zero >/dev/null 2>/dev/null) >/dev/null; then
		echo "error: \"$DESTINATION\" contains data and must be empty to continue"
		return 3
	fi
	
	local DEVICE_MODEL=$(hdparm -I "$DESTINATION" 2>/dev/null | grep --text 'Model Number' | cut -d ':' -f 2 | sed -r -e 's/ *(.*?) */\1/')
	local DEVICE_SERIAL=$(hdparm -I "$DESTINATION" 2>/dev/null | grep --text 'Serial Number' | cut -d ':' -f 2 | sed -r -e 's/ *(.*?) */\1/')
	local DEVICE_SIZE=$(blockdev --getsize64 "$DESTINATION")
	local DEVICE_SIZE_BLOCKS=$(($DEVICE_SIZE/$DEVICE_BLOCK_SIZE))
	
	local BOOT_SIZE_BLOCKS=$((512*1024*1024/$DEVICE_BLOCK_SIZE))
	if [ $(($BOOT_SIZE_BLOCKS*$DEVICE_BLOCK_SIZE)) -lt $((512*1024*1024)) ]; then
		BOOT_SIZE_BLOCKS=$((512*1024*1024/$DEVICE_BLOCK_SIZE + 1))
	fi
	local SWAP_SIZE_BLOCKS=$((8192*1024*1024/$DEVICE_BLOCK_SIZE))
	if [ $(($SWAP_SIZE_BLOCKS*$DEVICE_BLOCK_SIZE)) -lt $((8192*1024*1024)) ]; then
		SWAP_SIZE_BLOCKS=$((8192*1024*1024/$DEVICE_BLOCK_SIZE + 1))
	fi
	# leave one block at the beginning for the partition table, and one block at the end for rounding errors
	local ROOT_SIZE_BLOCKS=$(($DEVICE_SIZE_BLOCKS - 1 - $BOOT_SIZE_BLOCKS - $SWAP_SIZE_BLOCKS - 1 ))
	
	echo "Creating a $DEVICE_PARTITION_TYPE partition table and destination filesystems:"
	echo "  Device: $DESTINATION"
	if [ "$DEVICE_MODEL" != "" ]; then
		echo "  Model Number: $DEVICE_MODEL"
	fi
	if [ "$DEVICE_SERIAL" != "" ]; then
		echo "  Serial Number: $DEVICE_SERIAL"
	fi
	echo "  Size: $DEVICE_SIZE Bytes"
	echo "  Block Alignment Size: $DEVICE_BLOCK_SIZE Bytes"
	echo "  Boot Partition Size: $(($BOOT_SIZE_BLOCKS*$DEVICE_BLOCK_SIZE)) Bytes"
	echo "  Root Partition Size: $(($ROOT_SIZE_BLOCKS*$DEVICE_BLOCK_SIZE)) Bytes"
	echo "  Swap Partition Size: $(($SWAP_SIZE_BLOCKS*$DEVICE_BLOCK_SIZE)) Bytes"
	echo "Press CTRL+C to cancel"
	for SECONDS in $(seq 5 -1 1); do
		printf "\r${SECONDS} ... "
		sleep 1
	done
	printf "\r0 ... \n"
	
	echo -n "Creating the $DEVICE_PARTITION_TYPE partition table... "
	parted --script "$DESTINATION" mklabel $DEVICE_PARTITION_TYPE
	echo "done."
	echo -n "Creating the fat32 EFI partition... "
	parted --script "$DESTINATION" mkpart primary fat32 "$DEVICE_BLOCK_SIZE"b $(($DEVICE_BLOCK_SIZE + $DEVICE_BLOCK_SIZE*$BOOT_SIZE_BLOCKS - 1))b
	parted --script "$DESTINATION" set 1 boot on
	partprobe "$DESTINATION"
	sleep 1
	gentooinstall_quiet mkfs.vfat -F 32 "$DESTINATION"*1 || return
	sleep 1
	DESTINATION_BOOT_UUID=$(blkid -s UUID -o value "$DESTINATION"*1)
	echo "done."
	echo -n "Creating the btrfs root partition... "
	parted --script "$DESTINATION" mkpart primary btrfs $(($DEVICE_BLOCK_SIZE + $DEVICE_BLOCK_SIZE*$BOOT_SIZE_BLOCKS))b $(($DEVICE_BLOCK_SIZE + $DEVICE_BLOCK_SIZE*$BOOT_SIZE_BLOCKS + $DEVICE_BLOCK_SIZE*$ROOT_SIZE_BLOCKS - 1))b
	partprobe "$DESTINATION"
	sleep 1
	gentooinstall_quiet mkfs.btrfs -f "$DESTINATION"*2 || return
	sleep 1
	DESTINATION_ROOT_UUID=$(blkid -s UUID -o value "$DESTINATION"*2)
	echo "done."
	echo -n "Creating the swap partition... "
	parted --script "$DESTINATION" mkpart primary linux-swap $(($DEVICE_BLOCK_SIZE + $DEVICE_BLOCK_SIZE*$BOOT_SIZE_BLOCKS + $DEVICE_BLOCK_SIZE*$ROOT_SIZE_BLOCKS))b $(($DEVICE_BLOCK_SIZE + $DEVICE_BLOCK_SIZE*$BOOT_SIZE_BLOCKS + $DEVICE_BLOCK_SIZE*$ROOT_SIZE_BLOCKS + $DEVICE_BLOCK_SIZE*$SWAP_SIZE_BLOCKS - 1))b
	partprobe "$DESTINATION"
	sleep 1
	gentooinstall_quiet mkswap "$DESTINATION"*3 || return
	sleep 1
	DESTINATION_SWAP_UUID=$(blkid -s UUID -o value "$DESTINATION"*3)
	echo "done."
	local MEMORY_PHYSICAL=$(free -b | grep Mem | sed -r 's/[^0-9]+([0-9]+) .*/\1/')
	local MEMORY_SWAP=$(free -b | grep Swap | sed -r 's/[^0-9]+([0-9]+) .*/\1/')
	local MEMORY_TOTAL=$(($MEMORY_PHYSICAL+$MEMORY_SWAP))
	if [ $MEMORY_TOTAL -lt $((1024*1024*1024*4)) ]; then
		echo "Physical memory available: $MEMORY_PHYSICAL Bytes"
		echo "Swap memory available: $MEMORY_SWAP Bytes"
		echo "Total memory available: $MEMORY_TOTAL Bytes"
		echo "Less than 4GiB of memory detected"
		echo -n "Activating the destination swap partition... "
		swapon "$DESTINATION"*3
		echo "done."
	fi
}

function gentooinstall_phase_mount
{
	mkdir -p "$DESTINATION_ROOT"
	if [ "$DESTINATION_ROOT_UUID" = "" ]; then
		gentooinstall_detect_root_device || return
		mount "$DESTINATION_ROOT_DEVICE" "$DESTINATION_ROOT" || return
	else
		mount -U "$DESTINATION_ROOT_UUID" "$DESTINATION_ROOT" || return
	fi

	mkdir -p "$DESTINATION_ROOT"/boot/efi
	if [ "$DESTINATION_BOOT_UUID" = "" ]; then
		gentooinstall_detect_boot_device
		if [ $? -eq 0 ]; then
			mount --source "$DESTINATION_BOOT_DEVICE" "$DESTINATION_ROOT"/boot/efi || return
		else
			echo "Continuing without a separate boot filesystem..."
		fi
	else
		mount -U "$DESTINATION_BOOT_UUID" "$DESTINATION_ROOT"/boot/efi || return
	fi
}

function gentooinstall_phase_stage3download-no
{
	#echo "********!!!!!!!!!!!*********"
	#echo "Cambie de pantalla y copie el stage3-*.tar.xz"
	#read -p "Pulse una Tecla..."
	
	local STAGE3=$(ls /mnt/x/Gentoinst/stage?-*.tar.* | head -n 1)
	echo -n "Extracting \"$STAGE3\" to \"$DESTINATION_ROOT\"... "
	cp "$STAGE3" "$DESTINATION_ROOT" || return

	echo "done."


# \brief Download the latest stage3 tarball
function gentooinstall_phase_stage3download
{
	echo -n "Downloading the stage 3 tarball... "
	mkdir -p "$DESTINATION_ROOT"
	if [ "$STAGE3" = "latest" ]; then
		case "$ARCHITECTURE" in
			'i486'|'i686'|'x86_64'|'armv4'|'armv5'|'armv6'|'armv6hf'|'armv7'|'armv7hf'|'ppc'|'ppc64'|'alpha')
				case "$ARCHITECTURE" in
					'i486') LATEST=$(wget --quiet "$MIRROR/releases/x86/autobuilds/latest-stage3-i486.txt" -O-| tail -n 1 | cut -d " " -f 1);;
					'i686') LATEST=$(wget --quiet "$MIRROR/releases/x86/autobuilds/latest-stage3-i686.txt" -O-| tail -n 1 | cut -d " " -f 1);;
					'x86_64') LATEST=$(wget --quiet "$MIRROR/releases/amd64/autobuilds/latest-stage3-amd64.txt" -O-| tail -n 1 | cut -d " " -f 1);;
					'armv4') LATEST=$(wget --quiet "$MIRROR/releases/arm/autobuilds/latest-stage3-armv4tl.txt" -O-| tail -n 1 | cut -d " " -f 1);;
					'armv5') LATEST=$(wget --quiet "$MIRROR/releases/arm/autobuilds/latest-stage3-armv5tel.txt" -O-| tail -n 1 | cut -d " " -f 1);;
					'armv6') LATEST=$(wget --quiet "$MIRROR/releases/arm/autobuilds/latest-stage3-armv6j.txt" -O-| tail -n 1 | cut -d " " -f 1);;
					'armv6hf') LATEST=$(wget --quiet "$MIRROR/releases/arm/autobuilds/latest-stage3-armv6j_hardfp.txt" -O-| tail -n 1 | cut -d " " -f 1);;
					'armv7') LATEST=$(wget --quiet "$MIRROR/releases/arm/autobuilds/latest-stage3-armv7a.txt" -O-| tail -n 1 | cut -d " " -f 1);;
					'armv7hf') LATEST=$(wget --quiet "$MIRROR/releases/arm/autobuilds/latest-stage3-armv7a_hardfp.txt" -O-| tail -n 1 | cut -d " " -f 1);;
					'ppc') LATEST=$(wget --quiet "$MIRROR/releases/ppc/autobuilds/latest-stage3-ppc.txt" -O-| tail -n 1 | cut -d " " -f 1);;
					'ppc64') LATEST=$(wget --quiet "$MIRROR/releases/ppc/autobuilds/latest-stage3-ppc64.txt" -O-| tail -n 1 | cut -d " " -f 1);;
					'alpha') LATEST=$(wget --quiet "$MIRROR/releases/alpha/autobuilds/latest-stage3-alpha.txt" -O-| tail -n 1 | cut -d " " -f 1);;
				esac
				BASENAME=$(basename "$LATEST")
				STAGE3_FILE="$DESTINATION_ROOT/$BASENAME"
				case "$ARCHITECTURE" in
					'i486') wget -q "$MIRROR/releases/x86/autobuilds/$LATEST" -O "$STAGE3_FILE";;
					'i686') wget -q "$MIRROR/releases/x86/autobuilds/$LATEST" -O "$STAGE3_FILE";;
					'x86_64') wget -q "$MIRROR/releases/amd64/autobuilds/$LATEST" -O "$STAGE3_FILE";;
					'armv4') wget -q "$MIRROR/releases/arm/autobuilds/$LATEST" -O "$STAGE3_FILE";;
					'armv5') wget -q "$MIRROR/releases/arm/autobuilds/$LATEST" -O "$STAGE3_FILE";;
					'armv6') wget -q "$MIRROR/releases/arm/autobuilds/$LATEST" -O "$STAGE3_FILE";;
					'armv6hf') wget -q "$MIRROR/releases/arm/autobuilds/$LATEST" -O "$STAGE3_FILE";;
					'armv7') wget -q "$MIRROR/releases/arm/autobuilds/$LATEST" -O "$STAGE3_FILE";;
					'armv7hf') wget -q "$MIRROR/releases/arm/autobuilds/$LATEST" -O "$STAGE3_FILE";;
					'ppc') wget -q "$MIRROR/releases/ppc/autobuilds/$LATEST" -O "$STAGE3_FILE";;
					'ppc64') wget -q "$MIRROR/releases/ppc/autobuilds/$LATEST" -O "$STAGE3_FILE";;
					'alpha') wget -q "$MIRROR/releases/alpha/autobuilds/$LATEST" -O "$STAGE3_FILE";;
				esac
				STAGE3_HASHES="$DESTINATION_ROOT/$BASENAME.DIGESTS.asc"
				case "$ARCHITECTURE" in
					'i486') wget -q "$MIRROR/releases/x86/autobuilds/$LATEST.DIGESTS.asc" -O "$STAGE3_HASHES";;
					'i686') wget -q "$MIRROR/releases/x86/autobuilds/$LATEST.DIGESTS.asc" -O "$STAGE3_HASHES";;
					'x86_64') wget -q "$MIRROR/releases/amd64/autobuilds/$LATEST.DIGESTS.asc" -O "$STAGE3_HASHES";;
					'armv4') wget -q "$MIRROR/releases/arm/autobuilds/$LATEST.DIGESTS.asc" -O "$STAGE3_HASHES";;
					'armv5') wget -q "$MIRROR/releases/arm/autobuilds/$LATEST.DIGESTS.asc" -O "$STAGE3_HASHES";;
					'armv6') wget -q "$MIRROR/releases/arm/autobuilds/$LATEST.DIGESTS.asc" -O "$STAGE3_HASHES";;
					'armv6hf') wget -q "$MIRROR/releases/arm/autobuilds/$LATEST.DIGESTS.asc" -O "$STAGE3_HASHES";;
					'armv7') wget -q "$MIRROR/releases/arm/autobuilds/$LATEST.DIGESTS.asc" -O "$STAGE3_HASHES";;
					'armv7hf') wget -q "$MIRROR/releases/arm/autobuilds/$LATEST.DIGESTS.asc" -O "$STAGE3_HASHES";;
					'ppc') wget -q "$MIRROR/releases/ppc/autobuilds/$LATEST.DIGESTS.asc" -O "$STAGE3_HASHES";;
					'ppc64') wget -q "$MIRROR/releases/ppc/autobuilds/$LATEST.DIGESTS.asc" -O "$STAGE3_HASHES";;
					'alpha') wget -q "$MIRROR/releases/alpha/autobuilds/$LATEST.DIGESTS.asc" -O "$STAGE3_HASHES";;
				esac
				;;
			"aarch64")
				BASENAME=$(wget "$MIRROR/experimental/arm64/" -O - 2>/dev/null | grep -E -o "\"stage3-arm64-[0-9]+.tar.bz2\"" | sed -r -e "s/\"(.*)\"/\1/" | tail -n 1)
				STAGE3_FILE="$DESTINATION_ROOT/$BASENAME"
				wget -q "$MIRROR/experimental/arm64/$BASENAME" -O "$STAGE3_FILE"
				STAGE3_HASHES="$DESTINATION_ROOT/$BASENAME.DIGESTS"
				wget -q "$MIRROR/experimental/arm64/$BASENAME.DIGESTS" -O "$STAGE3_HASHES"
				;;
			*)
				echo "error: unsupported architecture: $ARCHITECTURE"
				exit 1;;
		esac
	else
		BASENAME=$(basename "$STAGE3")
		wget -q "$STAGE3" -O "$DESTINATION_ROOT/$BASENAME.tar.gz"
		wget -q "$STAGE3.DIGESTS.asc" -O "$DESTINATION_ROOT/$BASENAME.DIGESTS.asc"
	fi
	echo "done."
}


function gentooinstall_phase_stage3extract
{
	local STAGE3=$(ls "$DESTINATION_ROOT"/stage?-*.tar.* | head -n 1)
	echo -n "Extracting \"$STAGE3\" to \"$DESTINATION_ROOT\"... "
	tar xpf "$STAGE3" -C "$DESTINATION_ROOT" --xattrs-include="*.*" --numeric-owner || return
	echo "MAKEOPTS=\"-j8\"" >> "$DESTINATION_ROOT"/etc/portage/make.conf
	echo "USE=\"-gtk -gnome qt4 qt5 kde dvd alsa cdr\"" >> "$DESTINATION_ROOT"/etc/portage/make.conf
	echo "GRUB_PLATFORMS=\"efi-64\"" >> "$DESTINATION_ROOT"/etc/portage/make.conf
	nano "$DESTINATION_ROOT"/etc/portage/make.conf

	mirrorselect -i -o >> "$DESTINATION_ROOT"/etc/portage/make.conf
	mkdir --parents "$DESTINATION_ROOT"/etc/portage/repos.conf
	cp "$DESTINATION_ROOT"/usr/share/portage/config/repos.conf "${DESTINATION_ROOT}"/etc/portage/repos.conf/gentoo.conf
	source "$DESTINATION_ROOT"/etc/profile
	
	echo "done."
}

function gentooinstall_phase_stage3delete
{
	rm "$DESTINATION_ROOT"/stage?-*.tar.*
}

function gentooinstall_phase_resolvconf
{
	if [ ! -f "$DESTINATION_ROOT/etc/resolv.conf" ]; then
		echo "Adding 8.8.8.8 and 8.8.4.4 to /etc/resolv.conf"
		echo "nameserver 8.8.8.8" >>"$DESTINATION_ROOT/etc/resolv.conf"
		echo "nameserver 8.8.4.4" >>"$DESTINATION_ROOT/etc/resolv.conf"
	fi

	echo "hostname=\"CVergara-Laptop\"" > "$DESTINATION_ROOT/etc/conf.d/hostname"
	echo "127.0.0.1     CVergara-Laptop localhost" > "$DESTINATION_ROOT/etc/hosts"

	nano "$DESTINATION_ROOT"/etc/rc.conf
	nano "$DESTINATION_ROOT"/etc/conf.d/keymaps
	nano "$DESTINATION_ROOT"/etc/conf.d/hwclock
}

function gentooinstall_phase_dynamictranslation
{
	ARCH_HOST=$(gentooinstall_architecture)
	ARCH_GUEST="$ARCHITECTURE"
	
	# do not install qemu for identical host and guest architectures
	if [ "$ARCH_HOST" = "$ARCH_GUEST" ]; then
		echo "Not installing qemu for dynamic binary translation because the host and guest are the same architecture."
		return 0
	fi
	
	# do not install qemu when the guest is supported by the host
	local ARCH_GUEST_NATIVELY_SUPPORTED=false
	if [ "$ARCH_HOST" = 'x86_64' ]; then
		if [ "$ARCH_GUEST" = 'i486' ]; then ARCH_GUEST_NATIVELY_SUPPORTED=true; fi
		if [ "$ARCH_GUEST" = 'i686' ]; then ARCH_GUEST_NATIVELY_SUPPORTED=true; fi
	fi
	if [ "$ARCH_HOST" = 'aarch64' ]; then
		if [ "$ARCH_GUEST" = 'armv4' ]; then ARCH_GUEST_NATIVELY_SUPPORTED=true; fi
		if [ "$ARCH_GUEST" = 'armv5' ]; then ARCH_GUEST_NATIVELY_SUPPORTED=true; fi
		if [ "$ARCH_GUEST" = 'armv6' ]; then ARCH_GUEST_NATIVELY_SUPPORTED=true; fi
		if [ "$ARCH_GUEST" = 'armv6hf' ]; then ARCH_GUEST_NATIVELY_SUPPORTED=true; fi
		if [ "$ARCH_GUEST" = 'armv7' ]; then ARCH_GUEST_NATIVELY_SUPPORTED=true; fi
		if [ "$ARCH_GUEST" = 'armv7hf' ]; then ARCH_GUEST_NATIVELY_SUPPORTED=true; fi
	fi
	if [ "$ARCH_HOST" = 'armv7hf' ]; then
		if [ "$ARCH_GUEST" = 'armv4' ]; then ARCH_GUEST_NATIVELY_SUPPORTED=true; fi
		if [ "$ARCH_GUEST" = 'armv5' ]; then ARCH_GUEST_NATIVELY_SUPPORTED=true; fi
		if [ "$ARCH_GUEST" = 'armv6' ]; then ARCH_GUEST_NATIVELY_SUPPORTED=true; fi
		if [ "$ARCH_GUEST" = 'armv6hf' ]; then ARCH_GUEST_NATIVELY_SUPPORTED=true; fi
		if [ "$ARCH_GUEST" = 'armv7' ]; then ARCH_GUEST_NATIVELY_SUPPORTED=true; fi
	fi
	if [ "$ARCH_HOST" = 'armv6hf' ]; then
		if [ "$ARCH_GUEST" = 'armv4' ]; then ARCH_GUEST_NATIVELY_SUPPORTED=true; fi
		if [ "$ARCH_GUEST" = 'armv5' ]; then ARCH_GUEST_NATIVELY_SUPPORTED=true; fi
		if [ "$ARCH_GUEST" = 'armv6' ]; then ARCH_GUEST_NATIVELY_SUPPORTED=true; fi
	fi
	if $ARCH_GUEST_NATIVELY_SUPPORTED; then
		echo "Not installing qemu for dynamic binary translation because the guest architecture is natively supported by the host."
		return 0
	fi
	
	# beyond this point install qemu because the guest is not natively supported by the host
	
	echo -n "Verifying kernel support for 'misc binaries'..."
	if [ ! -d /proc/sys/fs/binfmt_misc ]; then
		echo " Failed."
		echo "error: kernel support for 'misc binaries' is required"
		echo "hint: on Gentoo this can be enabled by starting the qemu-binfmt service"
		return 2
	fi
	echo " Success."
	
	case "$ARCH_GUEST" in
		"aarch64")
			echo -n "Verifying that \"/usr/bin/qemu-aarch64\" is a static binary..."
			if ! file /usr/bin/qemu-aarch64 | grep 'statically linked' >/dev/null; then
				echo " Failed."
				echo "error: the file \"/usr/bin/qemu-aarch64\" is not a static binary"
				echo "hint: on Gentoo this can be fixed by enabling the static-user use flag for app-emulation/qemu"
				return 3
			fi
			echo " Success."
			;;
		"armv4" | "armv5" | "armv6" | "armv6hf" | "armv7" | "armv7hf")
			echo -n "Verifying that \"/usr/bin/qemu-arm\" is a static binary..."
			if ! file /usr/bin/qemu-arm | grep 'statically linked' >/dev/null; then
				echo " Failed."
				echo "error: the file \"/usr/bin/qemu-arm\" is not a static binary"
				echo "hint: on Gentoo this can be fixed by enabling the static-user use flag for app-emulation/qemu"
				return 3
			fi
			echo " Success."
			;;
		"ppc")
			echo -n "Verifying that \"/usr/bin/qemu-ppc\" is a static binary..."
			if ! file /usr/bin/qemu-ppc | grep 'statically linked' >/dev/null; then
				echo " Failed."
				echo "error: the file \"/usr/bin/qemu-ppc\" is not a static binary"
				echo "hint: on Gentoo this can be fixed by enabling the static-user use flag for app-emulation/qemu"
				return 3
			fi
			echo " Success."
			;;
		"ppc64")
			echo -n "Verifying that \"/usr/bin/qemu-ppc64\" is a static binary..."
			if ! file /usr/bin/qemu-ppc64 | grep 'statically linked' >/dev/null; then
				echo " Failed."
				echo "error: the file \"/usr/bin/qemu-ppc64\" is not a static binary"
				echo "hint: on Gentoo this can be fixed by enabling the static-user use flag for app-emulation/qemu"
				return 3
			fi
			echo " Success."
			;;
		"alpha")
			echo -n "Verifying that \"/usr/bin/qemu-alpha\" is a static binary..."
			if ! file /usr/bin/qemu-alpha | grep 'statically linked' >/dev/null; then
				echo " Failed."
				echo "error: the file \"/usr/bin/qemu-alpha\" is not a static binary"
				echo "hint: on Gentoo this can be fixed by enabling the static-user use flag for app-emulation/qemu"
				return 3
			fi
			echo " Success."
			;;
		*)
			echo "error: unsupported host/guest combination with host=$ARCH_HOST and guest=$ARCH_GUEST"
			return 1
			;;
	esac
	
	echo -n "Testing dynamic binary translation..."
	if ! "$DESTINATION_ROOT"/bin/busybox true >/dev/null 2>/dev/null; then
		echo " Failed."
		echo "error: dynamic translation test failed for \"$DESTINATION_ROOT/bin/busybox test\""
		echo "hint: try running the same test manually before continuing: \"$DESTINATION_ROOT/bin/busybox true\""
		echo "hint: on a gentoo host try starting the qemu-binfmt service"
		return 4
	fi
	echo " Success."
	
	case "$ARCH_GUEST" in
		"aarch64")
			echo -n "Copying \"/usr/bin/qemu-aarch64\" into the installation to enable dynamic binary translation..."
			cp /usr/bin/qemu-aarch64 "$DESTINATION_ROOT"/usr/bin
			echo " Done."
			;;
		"armv4" | "armv5" | "armv6" | "armv6hf" | "armv7" | "armv7hf")
			echo -n "Copying \"/usr/bin/qemu-arm\" into the installation to enable dynamic binary translation..."
			cp /usr/bin/qemu-arm "$DESTINATION_ROOT"/usr/bin
			echo " Done."
			;;
		"ppc")
			echo -n "Copying \"/usr/bin/qemu-ppc\" into the installation to enable dynamic binary translation..."
			cp /usr/bin/qemu-ppc "$DESTINATION_ROOT"/usr/bin
			echo " Done."
			;;
		"ppc64")
			echo -n "Copying \"/usr/bin/qemu-ppc64\" into the installation to enable dynamic binary translation..."
			cp /usr/bin/qemu-ppc64 "$DESTINATION_ROOT"/usr/bin
			echo " Done."
			;;
		"alpha")
			echo -n "Copying \"/usr/bin/qemu-alpha\" into the installation to enable dynamic binary translation..."
			cp /usr/bin/qemu-alpha "$DESTINATION_ROOT"/usr/bin
			echo " Done."
			;;
		*)
			echo "error: unsupported host/guest combination with host=$ARCH_HOST and guest=$ARCH_GUEST"
			return 1
			;;
	esac
}

function gentooinstall_phase_procsysdev
{
	if ! findmnt "$DESTINATION_ROOT/proc" >/dev/null; then
		mount -t proc /proc "$DESTINATION_ROOT/proc"
	fi
	if ! findmnt "$DESTINATION_ROOT/sys" >/dev/null; then
		mount --rbind /sys "$DESTINATION_ROOT/sys"
		mount --make-rslave "$DESTINATION_ROOT/sys"
	fi
	if ! findmnt "$DESTINATION_ROOT/dev" >/dev/null; then
		mount --rbind /dev "$DESTINATION_ROOT/dev"
		mount --make-rslave "$DESTINATION_ROOT/dev"
	fi
}

function gentooinstall_phase_portage
{
	gentooinstall_phase_procsysdev
	local PREFIX="$CHROOTARCH chroot $DESTINATION_ROOT /bin/bash"
	if [ "$DESTINATION" = '/' ]; then
		PREFIX=""
	fi

	echo -n "Installing portage... "
	if [ "$PORTAGE" = "latest" ]; then
		#gentooinstall_quiet 
		$PREFIX emerge-webrsync || return
		$PREFIX emerge --sync || return
	else
		$PREFIX wget "$PORTAGE" -O /tmp/portage.tar.bz2 || return
		$PREFIX tar xjpf /tmp/portage.tar.bz2 -C /usr || return
	fi
	#$PREFIX mkdir -p /etc/portage/package.keywords
	#$PREFIX touch /etc/portage/package.keywords/zzzz-autounmask-write
	#$PREFIX mkdir -p /etc/portage/package.use
	#$PREFIX touch /etc/portage/package.use/zzzz-autounmask-write
	eselect profile list
	readline loc
	eselect profile set $loc
	env-update && source /etc/profile && export PS1="(chroot) ${PS1}"
	# gentooinstall_quiet $PREFIX emerge --ask --verbose --update --deep --newuse @world || return
	$PREFIX emerge --ask --verbose --update --deep --newuse @world

	echo "done."
}

function gentooinstall_phase_timezone
{
	gentooinstall_phase_procsysdev
	local PREFIX="$CHROOTARCH chroot $DESTINATION_ROOT /bin/bash"
	if [ "$DESTINATION" = '/' ]; then
		PREFIX=""
	fi

	echo -n "Setting the timezone to \"$TIMEZONE\"... "
	echo "$TIMEZONE" >"$DESTINATION_ROOT/etc/timezone"
	gentooinstall_quiet $PREFIX emerge --config sys-libs/timezone-data

	echo "done."
}

function gentooinstall_phase_locale
{
	gentooinstall_phase_procsysdev
	local PREFIX="$CHROOTARCH chroot $DESTINATION_ROOT /bin/bash"
	if [ "$DESTINATION" = '/' ]; then
		PREFIX=""
	fi

	echo -n "Setting the locale to \"es_PE.UTF-8 UTF-8\" and \"en_US.UTF-8 UTF-8\"... "
	echo "es_PE.UTF-8 UTF-8"  >"$DESTINATION_ROOT/etc/locale.gen"
	echo "en_US.UTF-8 UTF-8" >>"$DESTINATION_ROOT/etc/locale.gen"
	gentooinstall_quiet $PREFIX locale-gen
	gentooinstall_quiet $PREFIX eselect locale set es_PE.utf8

	echo "done."
}

function gentooinstall_phase_kernel
{
	gentooinstall_phase_procsysdev
	local PREFIX="$CHROOTARCH chroot $DESTINATION_ROOT /bin/bash"
	if [ "$DESTINATION" = '/' ]; then
		PREFIX=""
	fi

	FEATURES="-pid-sandbox" $PREFIX emerge -uq app-arch/cpio
	FEATURES="-pid-sandbox" $PREFIX emerge -uq sys-apps/pciutils
	FEATURES="-pid-sandbox" $PREFIX emerge -uq sys-kernel/gentoo-sources
	FEATURES="-pid-sandbox" $PREFIX emerge -uq sys-kernel/genkernel
#	if [ ! -f .config ]; then
#		$PREFIX make -C "/usr/src/linux" defconfig
#	fi
#	$PREFIX make -C "/usr/src/linux" # -j $THREADS
#	$PREFIX make -C "/usr/src/linux" modules_install

	$PREFIX genkernel all
	$PREFIX genkernel --install initramfs
	FEATURES="-pid-sandbox" $PREFIX emerge -uq sys-kernel/linux-firmware
	FEATURES="-pid-sandbox" $PREFIX emerge --ask --noreplace sys-firmware/intel-microcode

	echo "done."	
}

function gentooinstall_phase_fstab
{
	echo -n "Updating /etc/fstab... "
	
	gentooinstall_detect_boot_uuid || return
	gentooinstall_detect_root_uuid || return
	gentooinstall_detect_swap_uuid || return
	
	mv -n "$DESTINATION_ROOT/etc/fstab" "$DESTINATION_ROOT/etc/fstab.example"
	echo "# <fs>  <mountpoint>  <type>  <opts>  <dump/pass>" >"$DESTINATION_ROOT/etc/fstab"
	echo "UUID=$DESTINATION_BOOT_UUID  /boot/efi  vfat  umask=077,noauto,noatime  0 0" >>"$DESTINATION_ROOT/etc/fstab"
	echo "UUID=$DESTINATION_SWAP_UUID  none  swap  sw  0 0" >>"$DESTINATION_ROOT/etc/fstab"
	echo "UUID=$DESTINATION_ROOT_UUID  /  btrfs  noatime,discard,subvol=@  0 1" >>"$DESTINATION_ROOT/etc/fstab"
	echo "UUID=$DESTINATION_ROOT_UUID  /home  btrfs  noatime,discard,subvol=@home  0 2" >>"$DESTINATION_ROOT/etc/fstab"
	
	echo "done."
}

function gentooinstall_phase_network
{
	gentooinstall_phase_procsysdev
	local PREFIX="$CHROOTARCH chroot $DESTINATION_ROOT /bin/bash"
	if [ "$DESTINATION" = '/' ]; then
		PREFIX=""
	fi

	gentooinstall_quiet $PREFIX emerge --ask --noreplace net-misc/netifrc
	gentooinstall_quiet $PREFIX emerge --ask net-misc/dhcpcd
	gentooinstall_quiet $PREFIX emerge --ask net-wireless/iw net-wireless/wpa_supplicant

	gentooinstall_quiet $PREFIX emerge --ask app-admin/sysklogd
	$PREFIX rc-update add sysklogd default
	gentooinstall_quiet $PREFIX emerge --ask sys-process/cronie
	$PREFIX rc-update add cronie default
	$PREFIX crontab /etc/crontab

	gentooinstall_quiet $PREFIX emerge --ask sys-apps/mlocate
	$PREFIX rc-update add sshd default
	gentooinstall_quiet $PREFIX emerge --ask sys-fs/btrfs-progs
	gentooinstall_quiet $PREFIX  emerge -av sys-fs/e2fsprogs
	gentooinstall_quiet $PREFIX  emerge -av sys-fs/dosfstools

	echo "done."
}

function gentooinstall_phase_bootloader
{
	case "$BOOTLOADER" in
		"bios-lilo")
			gentooinstall_phase_bootloader_bios_lilo || return
			;;
		"uefi-refind")
			gentooinstall_phase_bootloader_uefi_refind || return
			;;
		"grub-efi")
			gentooinstall_phase_bootloader_grub-efi || return
			;;
		*)
			echo "error: unsupported bootloader \"$BOOTLOADER\""
			return 1
			;;
	esac
}

function gentooinstall_phase_bootloader_bios_lilo
{
	gentooinstall_phase_procsysdev
	local PREFIX="$CHROOTARCH chroot $DESTINATION_ROOT  /bin/bash"
	if [ "$DESTINATION" = '/' ]; then
		PREFIX=""
	fi

	echo "Installing the lilo bootloader..."

	gentooinstall_detect_boot_device_parent || return
	gentooinstall_detect_root_partuuid || return

	FEATURES="-pid-sandbox" gentooinstall_quiet $PREFIX emerge -uq sys-boot/lilo

	KERNEL_MAKEFILE="$DESTINATION_ROOT/usr/src/linux/Makefile"
	if [ ! -f "$KERNEL_MAKEFILE" ]; then
		echo "error: A kernel makefile was not found at \"$KERNEL_MAKEFILE\""
		return 1
	fi
	KERNEL_VERSION=$(grep ^VERSION "$KERNEL_MAKEFILE" | sed -r 's/VERSION *= *//')
	KERNEL_PATCHLEVEL=$(grep ^PATCHLEVEL "$KERNEL_MAKEFILE" | sed -r 's/PATCHLEVEL *= *//')
	KERNEL_SUBLEVEL=$(grep ^SUBLEVEL "$KERNEL_MAKEFILE" | sed -r 's/SUBLEVEL *= *//')
	KERNEL_EXTRAVERSION=$(grep ^EXTRAVERSION "$KERNEL_MAKEFILE" | sed -r 's/EXTRAVERSION *= *-*//')

	KERNEL="$DESTINATION_ROOT/usr/src/linux/arch/$ARCHITECTURE/boot/bzImage"
	if [ ! -f "$KERNEL" ]; then
		echo "error: A kernel was not found at \"$KERNEL\""
		return 1
	fi

	KERNEL_FILENAME="vmlinuz-$KERNEL_VERSION"
	if [ "$KERNEL_PATCHLEVEL" != "" ]; then
		KERNEL_FILENAME="$KERNEL_FILENAME.$KERNEL_PATCHLEVEL"
	fi
	if [ "$KERNEL_SUBLEVEL" != "" ]; then
		KERNEL_FILENAME="$KERNEL_FILENAME.$KERNEL_SUBLEVEL"
	fi
	if [ "$KERNEL_EXTRAVERSION" != "" ]; then
		KERNEL_FILENAME="$KERNEL_FILENAME-$KERNEL_EXTRAVERSION"
	fi
	cp -f "$KERNEL" "$DESTINATION_ROOT/boot/$KERNEL_FILENAME"
	KERNEL="$KERNEL_FILENAME"

	# some hard drives use characters in their id that causes lilo to break when using boot=/dev/disk/by-id
	# this symlink is a workaround for that problem
	BOOTBYID=$(find -L "$DESTINATION_ROOT/dev/disk/by-id" -samefile "$DESTINATION_BOOT_DEVICE_PARENT" | head -n 1)
	if [ ! -b "$BOOTBYID" ]; then
		echo "error: the disk ID for \"$DESTINATION_BOOT_DEVICE_PARENT\" could not be identified."
		return 2
	fi

	echo "default=Gentoo" >"$DESTINATION_ROOT/etc/lilo.conf"
	echo "prompt" >>"$DESTINATION_ROOT/etc/lilo.conf"
	echo "timeout=100" >>"$DESTINATION_ROOT/etc/lilo.conf"
	echo "boot=/etc/lilo.conf.boot" >>"$DESTINATION_ROOT/etc/lilo.conf"
	echo "image=/boot/$KERNEL" >>"$DESTINATION_ROOT/etc/lilo.conf"
	echo "	label=Gentoo" >>"$DESTINATION_ROOT/etc/lilo.conf"
	echo "	append=\"root=PARTUUID=$DESTINATION_ROOT_PARTUUID rootwait\"" >>"$DESTINATION_ROOT/etc/lilo.conf"

	gentooinstall_quiet $PREFIX lilo -b "$DESTINATION_BOOT_DEVICE_PARENT"
}

function gentooinstall_phase_bootloader_uefi_refind
{
	gentooinstall_phase_procsysdev
	local PREFIX="$CHROOTARCH chroot $DESTINATION_ROOT /bin/bash"
	if [ "$DESTINATION" = '/' ]; then
		PREFIX=""
	fi

	echo "Installing the rEFInd bootloader..."

	gentooinstall_detect_boot_device || return
	gentooinstall_detect_root_partuuid || return

	FEATURES="-pid-sandbox" gentooinstall_quiet $PREFIX emerge -uq sys-boot/refind

	KERNEL_MAKEFILE="$DESTINATION_ROOT/usr/src/linux/Makefile"
	if [ ! -f "$KERNEL_MAKEFILE" ]; then
		echo "error: A kernel makefile was not found at \"$KERNEL_MAKEFILE\""
		return 1
	fi
	KERNEL_VERSION=$(grep ^VERSION "$KERNEL_MAKEFILE" | sed -r 's/VERSION *= *//')
	KERNEL_PATCHLEVEL=$(grep ^PATCHLEVEL "$KERNEL_MAKEFILE" | sed -r 's/PATCHLEVEL *= *//')
	KERNEL_SUBLEVEL=$(grep ^SUBLEVEL "$KERNEL_MAKEFILE" | sed -r 's/SUBLEVEL *= *//')
	KERNEL_EXTRAVERSION=$(grep ^EXTRAVERSION "$KERNEL_MAKEFILE" | sed -r 's/EXTRAVERSION *= *-*//')

	KERNEL="$DESTINATION_ROOT/usr/src/linux/arch/$ARCHITECTURE/boot/bzImage"
	if [ ! -f "$KERNEL" ]; then
		echo "error: A kernel was not found at \"$KERNEL\""
		return 1
	fi

	KERNEL_FILENAME="vmlinuz-$KERNEL_VERSION"
	if [ "$KERNEL_PATCHLEVEL" != "" ]; then
		KERNEL_FILENAME="$KERNEL_FILENAME.$KERNEL_PATCHLEVEL"
	fi
	if [ "$KERNEL_SUBLEVEL" != "" ]; then
		KERNEL_FILENAME="$KERNEL_FILENAME.$KERNEL_SUBLEVEL"
	fi
	if [ "$KERNEL_EXTRAVERSION" != "" ]; then
		KERNEL_FILENAME="$KERNEL_FILENAME-$KERNEL_EXTRAVERSION"
	fi
	cp -f "$KERNEL" "$DESTINATION_ROOT/boot/$KERNEL_FILENAME"

	$PREFIX refind-install --usedefault "$DESTINATION_BOOT_DEVICE"
	umount "$DESTINATION_ROOT/tmp/refind_install" >/dev/null 2>/dev/null
	rmdir "$DESTINATION_ROOT/tmp/refind_install"

	local REFIND_CONFIG=$(find "$DESTINATION_ROOT/boot" -name refind.conf)
	mv -n "$REFIND_CONFIG" "$REFIND_CONFIG".example
	local REFIND_OS_ICON=$(find "$DESTINATION_ROOT/boot" -name os_gentoo.png -printf '%P\n')
	echo "timeout 10" >"$REFIND_CONFIG"
	echo "scanfor manual" >"$REFIND_CONFIG"
	echo "menuentry Gentoo {" >>"$REFIND_CONFIG"
	echo "	icon $REFIND_OS_ICON" >>"$REFIND_CONFIG"
	echo "	loader $KERNEL_FILENAME" >>"$REFIND_CONFIG"
	echo "	options \"ro root=PARTUUID=$DESTINATION_ROOT_PARTUUID rootwait\"" >>"$REFIND_CONFIG"
	echo "}" >>"$REFIND_CONFIG"
}

function gentooinstall_phase_bootloader_grub-efi
{
	gentooinstall_phase_procsysdev
	local PREFIX="$CHROOTARCH chroot $DESTINATION_ROOT /bin/bash"
	if [ "$DESTINATION" = '/' ]; then
		PREFIX=""
	fi

	echo "Installing the GRUB-efi bootloader..."

	gentooinstall_detect_boot_device || return
	gentooinstall_detect_root_partuuid || return

	FEATURES="-pid-sandbox" gentooinstall_quiet $PREFIX emerge -uq sys-boot/grub:2
    $PREFIX mount -o remount,rw /sys/firmware/efi/efivars>/dev/null 2>/dev/null

	KERNEL_MAKEFILE="$DESTINATION_ROOT/usr/src/linux/Makefile"
	if [ ! -f "$KERNEL_MAKEFILE" ]; then
		echo "error: A kernel makefile was not found at \"$KERNEL_MAKEFILE\""
		return 1
	fi
	KERNEL_VERSION=$(grep ^VERSION "$KERNEL_MAKEFILE" | sed -r 's/VERSION *= *//')
	KERNEL_PATCHLEVEL=$(grep ^PATCHLEVEL "$KERNEL_MAKEFILE" | sed -r 's/PATCHLEVEL *= *//')
	KERNEL_SUBLEVEL=$(grep ^SUBLEVEL "$KERNEL_MAKEFILE" | sed -r 's/SUBLEVEL *= *//')
	KERNEL_EXTRAVERSION=$(grep ^EXTRAVERSION "$KERNEL_MAKEFILE" | sed -r 's/EXTRAVERSION *= *-*//')

	KERNEL="$DESTINATION_ROOT/usr/src/linux/arch/$ARCHITECTURE/boot/bzImage"
	if [ ! -f "$KERNEL" ]; then
		echo "error: A kernel was not found at \"$KERNEL\""
		return 1
	fi

	KERNEL_FILENAME="vmlinuz-$KERNEL_VERSION"
	if [ "$KERNEL_PATCHLEVEL" != "" ]; then
		KERNEL_FILENAME="$KERNEL_FILENAME.$KERNEL_PATCHLEVEL"
	fi
	if [ "$KERNEL_SUBLEVEL" != "" ]; then
		KERNEL_FILENAME="$KERNEL_FILENAME.$KERNEL_SUBLEVEL"
	fi
	if [ "$KERNEL_EXTRAVERSION" != "" ]; then
		KERNEL_FILENAME="$KERNEL_FILENAME-$KERNEL_EXTRAVERSION"
	fi
	cp -f "$KERNEL" "$DESTINATION_ROOT/boot/$KERNEL_FILENAME"

	$PREFIX grub-install --target=x86_64-efi --efi-directory=/boot/efi "$DESTINATION_BOOT_DEVICE"
	$PREFIX grub-mkconfig -o /boot/grub/grub.cfg
	$PREFIX update-grub
}

function gentooinstall_phase_update
{
	gentooinstall_phase_procsysdev
	local PREFIX="$CHROOTARCH chroot $DESTINATION_ROOT /bin/bash"
	if [ "$DESTINATION" = '/' ]; then
		PREFIX=""
	fi

	echo -n "Updating world packages... "
	FEATURES="-pid-sandbox" gentooinstall_quiet $PREFIX emerge -1u --backtrack=65536 sys-apps/portage || return
	FEATURES="-pid-sandbox" gentooinstall_quiet $PREFIX emerge -uDN --with-bdeps=y --backtrack=65536 world || return
	echo "done."
}

function gentooinstall_phase_password
{
	gentooinstall_phase_procsysdev
	local PREFIX="$CHROOTARCH chroot $DESTINATION_ROOT /bin/bash"
	if [ "$DESTINATION" = '/' ]; then
		PREFIX=""
	fi

	echo "root:$PASSWORD" | $PREFIX chpasswd
}

# \brief Run a command and only show output if an error occurs
# \param $@ The command and its arguments
function gentooinstall_quiet
{
	local RANDOM64=$(( $RANDOM * $RANDOM * $RANDOM * $RANDOM ))
	"$@" >>/tmp/.quiet.$RANDOM64 2>/tmp/.quiet.$RANDOM64
	local STATUS="$?"
	if [ "$STATUS" -ne 0 ]; then
		cat /tmp/.quiet.$RANDOM64
	fi
	rm -f /tmp/.quiet.$RANDOM64
	return "$STATUS"
}

#------------------------------------------------------------------------------
# default configuration

ARCHITECTURE=$(gentooinstall_architecture)
ASSIMILATE=false
BOOTLOADER=grub-efi
CHROOTARCH=""
DEBUG=false
DESTINATION="/mnt/gentoo"
DESTINATION_ROOT="/mnt/gentoo"
DESTINATION_ROOT_DEVICE=""
DESTINATION_BOOT_DEVICE=""
DESTINATION_BOOT_DEVICE_PARENT=""
DESTINATION_BOOT_UUID=""
DESTINATION_ROOT_PARTUUID=""
DESTINATION_ROOT_UUID=""
DESTINATION_SWAP_UUID=""
DEVICE_BLOCK_SIZE=$((1024*1024))
DEVICE_PARTITION_TYPE=gpt
MIRROR="http://distfiles.gentoo.org"
NICE=0
PASSWORD="1xt55rs8$"
#PHASES="stage3download,stage3signature,stage3hash,stage3extract,stage3delete,dynamictranslation,resolvconf,procsysdev,portage,timezone,locale,update,password"
PHASES="stage3download-no,stage3extract,stage3delete,dynamictranslation,network,resolvconf,procsysdev,portage,timezone,locale,update,password"
PHASES_DEFAULT=false
PORTAGE="latest"
STAGE3="latest"
THREADS=$(grep -c processor /proc/cpuinfo)
TIMEZONE="America/Lima"
TMP="/tmp"
VERBOSITY=0
NEWS=true
WARNING=true

#------------------------------------------------------------------------------
# command line arguments

if [ $# -eq 0 ]; then
	gentooinstall_help
	exit 1
fi

THIS="$0"
while [ $# -ne 0 ]; do
	case "$1" in
		#"--assimilate")
		#	ASSIMILATE=true
		#	shift 2
		#	;;
		"-a"|"--architecture")
			ARCHITECTURE="$2"
			shift 2
			;;
		"--bootloader")
			BOOTLOADER="$2"
			shift 2
			;;
		"-d"|"--destination")
			DESTINATION="$2"
			shift 2
			;;
		"--destination-root-partuuid")
			DESTINATION_ROOT_PARTUUID="$2"
			shift 2
			;;
		"-h"|"--help")
			gentooinstall_help
			exit
			;;
		"-m"|"--mountpoint")
			DESTINATION_ROOT="$2"
			shift 2
			;;
		"--mirror")
			MIRROR="$2"
			shift 2
			;;
		"--no-news")
			NEWS=false
			shift
			;;
		"--no-warning")
			WARNING=false
			shift
			;;
		"--partition-type")
			DEVICE_PARTITION_TYPE="$2"
			shift 2
			;;
		"--partition-block-size")
			DEVICE_BLOCK_SIZE="$2"
			shift 2
			;;
		"--password")
			PASSWORD="$2"
			shift 2
			;;
		"-p"|"--phase")
			PHASES_DEFAULT=true
			PHASES="$2"
			shift 2
			;;
		"--portage")
			PORTAGE="$2"
			shift 2
			;;
		"--stage3")
			STAGE3="$2"
			shift 2
			;;
		"-t"|"--timezone")
			TIMEZONE="$2"
			shift 2
			;;
		*)
			echo "error: unrecognized argument \"$1\""
			exit 1
			break;;
	esac
done

if [ "$(gentooinstall_architecture)" = "x86_64" -a "$ARCHITECTURE" = "i486" ]; then
	CHROOTARCH="linux32"
fi
if [ "$(gentooinstall_architecture)" = "x86_64" -a "$ARCHITECTURE" = "i686" ]; then
	CHROOTARCH="linux32"
fi

if test -f "$DESTINATION"; then
	DESTINATION_FILE="$DESTINATION"
	DESTINATION=$(losetup -j "$DESTINATION_FILE" | cut -d ':' -f 1)
	if [ -b "$DESTINATION" ]; then
		echo "using existing loop device for \"$DESTINATION_FILE\" which is \"$DESTINATION\"."
	else
		losetup -f "$DESTINATION_FILE"
		if [ $? -ne 0 ]; then
			echo "error: unable to setup loop device for \"$DESTINATION_FILE\""
			exit 1
		fi
		DESTINATION=$(losetup -j "$DESTINATION_FILE" | cut -d ':' -f 1)
		if [ ! -b "$DESTINATION" ]; then
			echo "error: unable to setup loop device for \"$DESTINATION_FILE\""
			exit 1
		fi
	fi
fi
if test -b "$DESTINATION" && ! $PHASES_DEFAULT; then
	PHASES="partition,mount,$PHASES"
fi
if [ ! -b "$DESTINATION" ]; then
	DESTINATION_ROOT="$DESTINATION"
fi

#------------------------------------------------------------------------------
# prepare environment

# alias diff to busybox if diff is missing
if ! type diff >/dev/null 2>/dev/null; then
	if /bin/busybox diff /bin/busybox /bin/busybox; then
		function diff
		{
			/bin/busybox diff "$@"
		}
	else
		echo "$CODENAME: \"diff\" is required for this application to work correctly." >&2
		exit 1
	fi
fi

#------------------------------------------------------------------------------
# begin execution

gentooinstall_phases
if [ $? -eq 0 ]; then
	gentooinstall_news
fi
